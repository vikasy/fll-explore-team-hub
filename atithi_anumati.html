<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Guest Access Helper</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 1rem; max-width: 700px; }
    h1 { color: #0052a3; }
    label { display:block; margin-top:0.75rem; font-weight:600; }
    input, select { padding:0.4rem; width:100%; max-width:420px; }
    button { background:#0052a3; color:#fff; border:none; padding:0.5rem 1rem; margin-top:1rem; cursor:pointer; }
    button:disabled { background:#777; cursor: not-allowed; }
    .log { background:#f5f5f5; padding:0.75rem; border:1px solid #ddd; margin-top:1rem; font-size:0.9rem; white-space:pre-wrap; }
    .success { color: #0a7a2a; font-weight:600; }
    .error { color: #b00020; font-weight:600; }
    .warning { color:#a36a00; }
    .role-row { display:flex; gap:1rem; flex-wrap:wrap; margin-top:0.5rem; }
    .role-row > label { font-weight:400; display:flex; align-items:center; gap:0.25rem; }
    footer { margin-top:2rem; font-size:0.8rem; color:#555; }
  </style>
</head>
<body>
  <h1>Guest / Role Access Helper</h1>
  <p>This page lets an <strong>admin</strong> create or update entries in <code>allowedUsers</code> for temporary guest viewing or permanent role flags. Keep this page private (do not link publicly).</p>
  <!-- Shared Secret Gate (Option 2: hashed secret) -->
  <div id="secret-gate" style="position:fixed;inset:0;background:rgba(0,0,0,0.55);display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="background:#fff;padding:1.25rem 1.5rem;border-radius:12px;max-width:420px;width:92%;box-shadow:0 4px 18px #0004;">
      <h2 style="margin-top:0;color:#0052a3;font-size:1.25rem;">Restricted Helper</h2>
      <p style="margin:0 0 0.75rem 0;line-height:1.35;">Enter the shared passphrase to continue. This is an additional light-weight barrier (hash verified client‑side). Rotate periodically.</p>
      <input type="password" id="secret-input" placeholder="Passphrase" style="width:100%;padding:0.55rem;border:1px solid #bbb;border-radius:6px;" autofocus />
      <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
        <button id="secret-submit" style="flex:1;">Unlock</button>
        <button id="secret-cancel" style="background:#777;flex:0 0 auto;">Clear</button>
      </div>
      <div id="secret-msg" style="margin-top:0.6rem;font-size:0.85rem;color:#b00020;min-height:1.1em;"></div>
      <details style="margin-top:0.75rem;">
        <summary style="cursor:pointer;font-size:0.8rem;">How to change secret</summary>
        <div style="font-size:0.7rem;line-height:1.2;margin-top:0.4rem;">
          1. Pick phrase. 2. Compute SHA‑256 hex (e.g. <code>echo -n 'MyPhrase' | shasum -a 256</code>).<br />
          3. Replace <code>SECRET_HASH</code> constant in file. 4. Commit & deploy.
        </div>
      </details>
    </div>
  </div>
  <div id="auth-box">
    <button id="login-btn">Login with Google</button>
    <button id="logout-btn" style="display:none;">Logout</button>
    <span id="user-info" style="margin-left:1rem;font-weight:bold;"></span>
    <div id="admin-status" style="margin-top:0.5rem;"></div>
  </div>
  <hr />
  <form id="guest-form" style="display:none;">
    <label>Email (guest or user to modify)</label>
    <input type="email" id="target-email" placeholder="guest@example.org" required />
    <label>Guest Duration (days) (optional note only)</label>
    <input type="number" id="guest-days" min="1" max="60" value="7" />
    <button type="submit" id="create-btn">Create / Update</button>
  </form>
  <div class="log" id="log-box"></div>
  <button id="access-logs-btn" style="display:none;margin-top:1rem;">Show Access Logs</button>
  <div id="access-logs-panel" style="display:none;margin-top:0.75rem;padding:0.75rem;border:1px solid #ccc;border-radius:8px;background:#fafafa;"></div>
  <footer>
    <p>Security: This page relies on Firestore rules. Only users with <code>admin: true</code> in their <code>allowedUsers</code> doc should use it. Remove the file if leaked.</p>
  </footer>
  <script>
    /* =============================================================
       Shared Secret Gate (Hash Compare)
       Replace SECRET_HASH with the SHA-256 hex digest of your phrase.
       Current hash corresponds to phrase placeholder: ReplaceMe123!
       DO NOT leave default in production. Generate your own strong phrase.
    ============================================================= */
  // Build meta: embedded at commit c15f1c1. Replace SECRET_HASH below with the SHA-256 of your chosen passphrase.
  // To set: open devtools console and run: copy(await (async ()=>{const enc=new TextEncoder().encode('YourPassphrase');const buf=await crypto.subtle.digest('SHA-256',enc);return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');})())
  // Then paste hash here and redeploy.
  const SECRET_HASH = 'b98b58aa290a625159292068d687e4c9844e334c36c1bc634a46c661af18b1d3'; // SHA-256 hash of secret phrase (colorYEARthing)
  let secretUnlocked = false;
  let failedAttempts = 0;
  let lockUntil = 0; // epoch ms when next attempt allowed
  const MAX_ATTEMPTS = 5;
  const LOCK_DURATION_MS = 180 * 1000; // 180 seconds
    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    function updateLockUI() {
      const msg = document.getElementById('secret-msg');
      const btn = document.getElementById('secret-submit');
      if (Date.now() < lockUntil) {
        const remaining = Math.ceil((lockUntil - Date.now()) / 1000);
        msg.textContent = 'Too many failed attempts. Wait ' + remaining + 's before retrying.';
        btn.disabled = true;
      } else {
        if (failedAttempts > 0 && failedAttempts < MAX_ATTEMPTS) {
          msg.textContent = 'Attempts: ' + failedAttempts + '/' + MAX_ATTEMPTS;
        }
        btn.disabled = false;
      }
    }

    // Periodically refresh cooldown display if locked
    setInterval(() => {
      if (lockUntil && Date.now() < lockUntil) updateLockUI();
      else if (lockUntil && Date.now() >= lockUntil) { lockUntil = 0; updateLockUI(); }
    }, 1000);

    async function attemptUnlock(){
      const inp = document.getElementById('secret-input');
      const msg = document.getElementById('secret-msg');
      const val = inp.value.trim();
      // Check lock first
      if (Date.now() < lockUntil) { updateLockUI(); return; }
      if (!val){ msg.textContent = 'Enter a passphrase.'; return; }
      msg.textContent = 'Verifying…';
      try {
        const h = await sha256Hex(val);
        if (h === SECRET_HASH){
          secretUnlocked = true;
          document.getElementById('secret-gate').style.display = 'none';
          msg.textContent = '';
          log('Secret gate unlocked', 'success');
          // Secret accepted; reset counters (auth box already active)
          failedAttempts = 0;
          lockUntil = 0;
          // If already signed in (e.g., redirect flow), reflect UI
          if (typeof handleAuth === 'function') handleAuth(auth.currentUser);
        } else {
          failedAttempts++;
          if (failedAttempts >= MAX_ATTEMPTS) {
            lockUntil = Date.now() + LOCK_DURATION_MS;
            updateLockUI();
          } else {
            msg.textContent = 'Incorrect passphrase. Attempts: ' + failedAttempts + '/' + MAX_ATTEMPTS;
            updateLockUI();
          }
        }
      } catch(e){
        msg.textContent = 'Error hashing secret.';
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('secret-submit').addEventListener('click', attemptUnlock);
      document.getElementById('secret-cancel').addEventListener('click', () => {
        document.getElementById('secret-input').value='';
        document.getElementById('secret-msg').textContent='';
      });
      document.getElementById('secret-input').addEventListener('keydown', e => { if(e.key==='Enter'){ attemptUnlock(); }});
      updateLockUI();
    });
    const firebaseConfig = {
      apiKey: "AIzaSyD3nbgoGy4LKZDWV8ILDsHmTQceNg1lE2c",
      authDomain: "fllex2wv.firebaseapp.com",
      projectId: "fllex2wv",
      storageBucket: "fllex2wv.appspot.com",
      messagingSenderId: "105509048133",
      appId: "1:105509048133:web:2655ec171befe83d09b82c"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const userInfo = document.getElementById('user-info');
    const adminStatus = document.getElementById('admin-status');
    const guestForm = document.getElementById('guest-form');
    const logBox = document.getElementById('log-box');
  const accessLogsBtn = document.getElementById('access-logs-btn');
  const accessLogsPanel = document.getElementById('access-logs-panel');

    function log(msg, cls) {
      const line = document.createElement('div');
      if (cls) line.classList.add(cls);
      line.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    // Environment sanity check (popup auth requires http/https, not file://)
    if (location.protocol !== 'http:' && location.protocol !== 'https:') {
      log('Warning: You are opening this page with protocol ' + location.protocol + '. Firebase auth popups will fail. Serve the site via a local web server (e.g., "firebase hosting:channel:deploy" or "npx http-server") or deploy to Firebase Hosting.', 'warning');
    }

    loginBtn.onclick = async () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      try {
        await auth.signInWithPopup(provider);
      } catch (e) {
        if (e && (e.code === 'auth/operation-not-supported-in-this-environment')) {
          log('Popup auth not supported in this environment. Attempting redirect sign-in...', 'warning');
          try {
            await auth.signInWithRedirect(provider);
          } catch (e2) {
            log('Redirect login failed: ' + e2.message, 'error');
          }
        } else {
          log('Login failed: ' + (e && e.message ? e.message : e), 'error');
        }
      }
    };
    logoutBtn.onclick = () => auth.signOut();

    async function getAllowedDocFor(user) {
      const email = (user.email || '').toLowerCase();
      const emailRef = db.collection('allowedUsers').doc(email);
      const snap = await emailRef.get();
      return { ref: emailRef, snap };
    }

    async function isAdmin(user) {
      if (!user) return false;
      try {
        const { snap } = await getAllowedDocFor(user);
        return snap.exists && snap.data().admin === true;
      } catch (e) {
        log('Admin check error: ' + e.message, 'error');
        return false;
      }
    }
    async function handleAuth(user){
      if (!secretUnlocked) return; // wait until secret gate passed
      if (user) {
        userInfo.textContent = user.email || user.uid;
        loginBtn.style.display = 'none';
        logoutBtn.style.display = '';
        let admin = false;
        try { admin = await isAdmin(user); } catch(_) {}
        if (admin) {
          adminStatus.innerHTML = '<span class="success">You are admin.</span>';
          guestForm.style.display = '';
          log('Admin login OK', 'success');
          if (accessLogsBtn) accessLogsBtn.style.display = '';
        } else {
          adminStatus.innerHTML = '<span class="error">You are not admin. Access restricted.</span>';
          guestForm.style.display = 'none';
          log('Non-admin user logged in, form hidden.', 'warning');
          if (accessLogsBtn) accessLogsBtn.style.display = 'none';
          if (accessLogsPanel) accessLogsPanel.style.display = 'none';
        }
      } else {
        userInfo.textContent = '';
        loginBtn.style.display = '';
        logoutBtn.style.display = 'none';
        guestForm.style.display = 'none';
        adminStatus.textContent = '';
        if (accessLogsBtn) accessLogsBtn.style.display = 'none';
        if (accessLogsPanel) accessLogsPanel.style.display = 'none';
      }
    }

    auth.onAuthStateChanged(user => handleAuth(user));

    document.getElementById('guest-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const user = auth.currentUser;
      if (!user) return log('Not signed in.', 'error');
      if (!(await isAdmin(user))) return log('Denied: not admin.', 'error');
      const email = document.getElementById('target-email').value.trim().toLowerCase();
      if (!email) return log('Email required', 'error');
      const guestDays = parseInt(document.getElementById('guest-days').value || '0', 10);
      const docRef = db.collection('allowedUsers').doc(email);
      const data = {
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        // Force guest-only role; explicitly set other roles false to avoid privilege carry-over.
        guest: true,
        parent: false,
        student: false,
        admin: false
      };
      if (guestDays > 0) {
        const expireDate = new Date(Date.now() + guestDays * 86400000);
        data.guestNote = 'Intended expire (manual): ' + expireDate.toISOString();
      } else {
        data.guestNote = firebase.firestore.FieldValue.delete();
      }
      try {
        await docRef.set(data, { merge: true });
        log('Guest-only access updated for ' + email, 'success');
      } catch (e2) {
        log('Write failed: ' + e2.message, 'error');
      }
    });

    // ================= Access Logs Viewer (Option 3.A) =================
    async function loadAccessLogs(limit=50) {
      if (!accessLogsPanel) return;
      accessLogsPanel.innerHTML = '<em>Loading access logs…</em>';
      try {
        const user = auth.currentUser;
        if (!user || !(await isAdmin(user))) {
          accessLogsPanel.innerHTML = '<span style="color:#b00020;">Not authorized.</span>';
          return;
        }
        const snap = await db.collection('accessLogs')
          .orderBy('ts','desc')
          .limit(limit)
          .get();
        if (snap.empty) {
          accessLogsPanel.innerHTML = '<em>No access log entries yet.</em>';
          return;
        }
        const rows = [];
        snap.forEach(doc => {
          const data = doc.data() || {};
          const ts = data.ts && data.ts.toDate ? data.ts.toDate() : null;
          rows.push({
            id: doc.id,
            email: data.email || '',
            uid: data.uid || '',
            date: data.date || '',
            tsISO: ts ? ts.toISOString() : ''
          });
        });
        let html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">'
          + '<strong>Recent Access Logs (' + rows.length + ')</strong>'
          + '<div style="font-size:0.8rem;display:flex;gap:0.5rem;">'
          + '<button id="access-logs-refresh" style="margin:0;padding:0.25rem 0.5rem;">Refresh</button>'
          + '<button id="access-logs-export" style="margin:0;padding:0.25rem 0.5rem;">CSV</button>'
          + '</div></div>';
        html += '<div style="max-height:280px;overflow:auto;border:1px solid #ddd;background:#fff;">';
        html += '<table style="width:100%;border-collapse:collapse;font-size:0.85rem;">'
          + '<thead><tr style="background:#eef;"><th style="padding:4px;border:1px solid #ccc;">Date</th><th style="padding:4px;border:1px solid #ccc;">Time (UTC)</th><th style="padding:4px;border:1px solid #ccc;">Email</th><th style="padding:4px;border:1px solid #ccc;">UID</th><th style="padding:4px;border:1px solid #ccc;">Doc ID</th></tr></thead><tbody>';
        rows.forEach(r => {
          let dateDisp = '', timeDisp = '';
          if (r.tsISO) {
            const dt = new Date(r.tsISO);
            dateDisp = dt.toISOString().substring(0,10);
            timeDisp = dt.toISOString().substring(11,19);
          } else if (r.date) {
            // fallback: date field only
            dateDisp = r.date;
          }
          html += '<tr>'
            + '<td style="padding:4px;border:1px solid #ddd;white-space:nowrap;">'+dateDisp+'</td>'
            + '<td style="padding:4px;border:1px solid #ddd;white-space:nowrap;">'+timeDisp+'</td>'
            + '<td style="padding:4px;border:1px solid #ddd;">'+(r.email||'')+'</td>'
            + '<td style="padding:4px;border:1px solid #ddd;">'+(r.uid||'')+'</td>'
            + '<td style="padding:4px;border:1px solid #ddd;">'+r.id+'</td>'
            + '</tr>';
        });
        html += '</tbody></table></div>';
        accessLogsPanel.innerHTML = html;
        const refreshBtn = document.getElementById('access-logs-refresh');
        if (refreshBtn) refreshBtn.onclick = () => loadAccessLogs(limit);
        const exportBtn = document.getElementById('access-logs-export');
        if (exportBtn) exportBtn.onclick = () => exportAccessLogsCSV(rows);
      } catch (e) {
        accessLogsPanel.innerHTML = '<span style="color:#b00020;">Failed to load logs: ' + (e && e.message ? e.message : e) + '</span>';
      }
    }

    function exportAccessLogsCSV(rows) {
      try {
        if (!rows || !rows.length) return;
        const header = ['id','email','uid','date','ts'].join(',');
        const lines = rows.map(r => [r.id, r.email, r.uid, r.date, r.tsISO].map(v => '"'+String(v||'').replace(/"/g,'""')+'"').join(','));
        const csv = [header, ...lines].join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'accessLogs_export.csv';
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
      } catch (e) {
        log('CSV export failed: ' + (e && e.message ? e.message : e), 'error');
      }
    }

    if (accessLogsBtn) {
      accessLogsBtn.addEventListener('click', () => {
        if (accessLogsPanel.style.display === 'none' || accessLogsPanel.style.display === '') {
          accessLogsPanel.style.display = 'block';
          loadAccessLogs();
          accessLogsBtn.textContent = 'Hide Access Logs';
        } else {
          accessLogsPanel.style.display = 'none';
          accessLogsBtn.textContent = 'Show Access Logs';
        }
      });
    }
  </script>
</body>
</html>
