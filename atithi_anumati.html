<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Guest Access Helper</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 1rem; max-width: 700px; }
    h1 { color: #0052a3; }
    label { display:block; margin-top:0.75rem; font-weight:600; }
    input, select { padding:0.4rem; width:100%; max-width:420px; }
    button { background:#0052a3; color:#fff; border:none; padding:0.5rem 1rem; margin-top:1rem; cursor:pointer; }
    button:disabled { background:#777; cursor: not-allowed; }
    .log { background:#f5f5f5; padding:0.75rem; border:1px solid #ddd; margin-top:1rem; font-size:0.9rem; white-space:pre-wrap; }
    .success { color: #0a7a2a; font-weight:600; }
    .error { color: #b00020; font-weight:600; }
    .warning { color:#a36a00; }
    .role-row { display:flex; gap:1rem; flex-wrap:wrap; margin-top:0.5rem; }
    .role-row > label { font-weight:400; display:flex; align-items:center; gap:0.25rem; }
    footer { margin-top:2rem; font-size:0.8rem; color:#555; }
  </style>
</head>
<body>
  <h1>Guest / Role Access Helper</h1>
  <p>This page lets an <strong>admin</strong> create or update entries in <code>allowedUsers</code> for temporary guest viewing or permanent role flags. Keep this page private (do not link publicly).</p>
  <!-- Shared Secret Gate (Option 2: hashed secret) -->
  <div id="secret-gate" style="position:fixed;inset:0;background:rgba(0,0,0,0.55);display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="background:#fff;padding:1.25rem 1.5rem;border-radius:12px;max-width:420px;width:92%;box-shadow:0 4px 18px #0004;">
      <h2 style="margin-top:0;color:#0052a3;font-size:1.25rem;">Restricted Helper</h2>
      <p style="margin:0 0 0.75rem 0;line-height:1.35;">Enter the shared passphrase to continue. This is an additional light-weight barrier (hash verified client‑side). Rotate periodically.</p>
      <input type="password" id="secret-input" placeholder="Passphrase" style="width:100%;padding:0.55rem;border:1px solid #bbb;border-radius:6px;" autofocus />
      <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
        <button id="secret-submit" style="flex:1;">Unlock</button>
        <button id="secret-cancel" style="background:#777;flex:0 0 auto;">Clear</button>
      </div>
      <div id="secret-msg" style="margin-top:0.6rem;font-size:0.85rem;color:#b00020;min-height:1.1em;"></div>
      <details style="margin-top:0.75rem;">
        <summary style="cursor:pointer;font-size:0.8rem;">How to change secret</summary>
        <div style="font-size:0.7rem;line-height:1.2;margin-top:0.4rem;">
          1. Pick phrase. 2. Compute SHA‑256 hex (e.g. <code>echo -n 'MyPhrase' | shasum -a 256</code>).<br />
          3. Replace <code>SECRET_HASH</code> constant in file. 4. Commit & deploy.
        </div>
      </details>
    </div>
  </div>
  <div id="auth-box">
    <button id="login-btn">Login with Google</button>
    <button id="logout-btn" style="display:none;">Logout</button>
    <span id="user-info" style="margin-left:1rem;font-weight:bold;"></span>
    <div id="admin-status" style="margin-top:0.5rem;"></div>
  </div>
  <hr />
  <form id="guest-form" style="display:none;">
    <label>Email (guest or user to modify)</label>
    <input type="email" id="target-email" placeholder="guest@example.org" required />
    <label>Base Role Flags</label>
    <div class="role-row">
      <label><input type="checkbox" id="role-parent" /> parent</label>
      <label><input type="checkbox" id="role-student" /> student</label>
      <label><input type="checkbox" id="role-admin" /> admin</label>
      <label><input type="checkbox" id="role-guest" /> guest (view-only if no other roles)</label>
    </div>
    <label>Guest Duration (days) — only applies if guest checked</label>
    <input type="number" id="guest-days" min="1" max="60" value="7" />
    <button type="submit" id="create-btn">Create / Update</button>
  </form>
  <div class="log" id="log-box"></div>
  <footer>
    <p>Security: This page relies on Firestore rules. Only users with <code>admin: true</code> in their <code>allowedUsers</code> doc should use it. Remove the file if leaked.</p>
  </footer>
  <script>
    /* =============================================================
       Shared Secret Gate (Hash Compare)
       Replace SECRET_HASH with the SHA-256 hex digest of your phrase.
       Current hash corresponds to phrase placeholder: ReplaceMe123!
       DO NOT leave default in production. Generate your own strong phrase.
    ============================================================= */
  // Build meta: embedded at commit c15f1c1. Replace SECRET_HASH below with the SHA-256 of your chosen passphrase.
  // To set: open devtools console and run: copy(await (async ()=>{const enc=new TextEncoder().encode('YourPassphrase');const buf=await crypto.subtle.digest('SHA-256',enc);return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');})())
  // Then paste hash here and redeploy.
  const SECRET_HASH = 'b98b58aa290a625159292068d687e4c9844e334c36c1bc634a46c661af18b1d3'; // SHA-256 hash of secret phrase (colorYEARthing)
  let secretUnlocked = false;
  let failedAttempts = 0;
  let lockUntil = 0; // epoch ms when next attempt allowed
  const MAX_ATTEMPTS = 5;
  const LOCK_DURATION_MS = 180 * 1000; // 180 seconds
    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    function updateLockUI() {
      const msg = document.getElementById('secret-msg');
      const btn = document.getElementById('secret-submit');
      if (Date.now() < lockUntil) {
        const remaining = Math.ceil((lockUntil - Date.now()) / 1000);
        msg.textContent = 'Too many failed attempts. Wait ' + remaining + 's before retrying.';
        btn.disabled = true;
      } else {
        if (failedAttempts > 0 && failedAttempts < MAX_ATTEMPTS) {
          msg.textContent = 'Attempts: ' + failedAttempts + '/' + MAX_ATTEMPTS;
        }
        btn.disabled = false;
      }
    }

    // Periodically refresh cooldown display if locked
    setInterval(() => {
      if (lockUntil && Date.now() < lockUntil) updateLockUI();
      else if (lockUntil && Date.now() >= lockUntil) { lockUntil = 0; updateLockUI(); }
    }, 1000);

    async function attemptUnlock(){
      const inp = document.getElementById('secret-input');
      const msg = document.getElementById('secret-msg');
      const val = inp.value.trim();
      // Check lock first
      if (Date.now() < lockUntil) { updateLockUI(); return; }
      if (!val){ msg.textContent = 'Enter a passphrase.'; return; }
      msg.textContent = 'Verifying…';
      try {
        const h = await sha256Hex(val);
        if (h === SECRET_HASH){
          secretUnlocked = true;
          document.getElementById('secret-gate').style.display = 'none';
          msg.textContent = '';
          log('Secret gate unlocked', 'success');
          // Allow auth box to operate now
          document.getElementById('auth-box').style.filter = '';
          failedAttempts = 0;
          lockUntil = 0;
        } else {
          failedAttempts++;
          if (failedAttempts >= MAX_ATTEMPTS) {
            lockUntil = Date.now() + LOCK_DURATION_MS;
            updateLockUI();
          } else {
            msg.textContent = 'Incorrect passphrase. Attempts: ' + failedAttempts + '/' + MAX_ATTEMPTS;
            updateLockUI();
          }
        }
      } catch(e){
        msg.textContent = 'Error hashing secret.';
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      // Blur underlying UI until unlocked
      document.getElementById('auth-box').style.filter = 'blur(3px)';
      document.getElementById('secret-submit').addEventListener('click', attemptUnlock);
      document.getElementById('secret-cancel').addEventListener('click', () => {
        document.getElementById('secret-input').value='';
        document.getElementById('secret-msg').textContent='';
      });
      document.getElementById('secret-input').addEventListener('keydown', e => { if(e.key==='Enter'){ attemptUnlock(); }});
      updateLockUI();
    });
    const firebaseConfig = {
      apiKey: "AIzaSyD3nbgoGy4LKZDWV8ILDsHmTQceNg1lE2c",
      authDomain: "fllex2wv.firebaseapp.com",
      projectId: "fllex2wv",
      storageBucket: "fllex2wv.appspot.com",
      messagingSenderId: "105509048133",
      appId: "1:105509048133:web:2655ec171befe83d09b82c"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const userInfo = document.getElementById('user-info');
    const adminStatus = document.getElementById('admin-status');
    const guestForm = document.getElementById('guest-form');
    const logBox = document.getElementById('log-box');

    function log(msg, cls) {
      const line = document.createElement('div');
      if (cls) line.classList.add(cls);
      line.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    // Environment sanity check (popup auth requires http/https, not file://)
    if (location.protocol !== 'http:' && location.protocol !== 'https:') {
      log('Warning: You are opening this page with protocol ' + location.protocol + '. Firebase auth popups will fail. Serve the site via a local web server (e.g., "firebase hosting:channel:deploy" or "npx http-server") or deploy to Firebase Hosting.', 'warning');
    }

    loginBtn.onclick = async () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      try {
        await auth.signInWithPopup(provider);
      } catch (e) {
        if (e && (e.code === 'auth/operation-not-supported-in-this-environment')) {
          log('Popup auth not supported in this environment. Attempting redirect sign-in...', 'warning');
          try {
            await auth.signInWithRedirect(provider);
          } catch (e2) {
            log('Redirect login failed: ' + e2.message, 'error');
          }
        } else {
          log('Login failed: ' + (e && e.message ? e.message : e), 'error');
        }
      }
    };
    logoutBtn.onclick = () => auth.signOut();

    async function getAllowedDocFor(user) {
      const email = (user.email || '').toLowerCase();
      const emailRef = db.collection('allowedUsers').doc(email);
      const snap = await emailRef.get();
      return { ref: emailRef, snap };
    }

    async function isAdmin(user) {
      if (!user) return false;
      try {
        const { snap } = await getAllowedDocFor(user);
        return snap.exists && snap.data().admin === true;
      } catch (e) {
        log('Admin check error: ' + e.message, 'error');
        return false;
      }
    }

    auth.onAuthStateChanged(async user => {
      if (!secretUnlocked) { return; } // ignore auth events until unlocked
      if (user) {
        userInfo.textContent = user.email || user.uid;
        loginBtn.style.display = 'none';
        logoutBtn.style.display = '';
        const admin = await isAdmin(user);
        if (admin) {
          adminStatus.innerHTML = '<span class="success">You are admin.</span>';
          guestForm.style.display = '';
          log('Admin login OK', 'success');
        } else {
          adminStatus.innerHTML = '<span class="error">You are not admin. Access restricted.</span>';
          guestForm.style.display = 'none';
          log('Non-admin user logged in, form hidden.', 'warning');
        }
      } else {
        userInfo.textContent = '';
        loginBtn.style.display = '';
        logoutBtn.style.display = 'none';
        guestForm.style.display = 'none';
        adminStatus.textContent = '';
      }
    });

    document.getElementById('guest-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const user = auth.currentUser;
      if (!user) return log('Not signed in.', 'error');
      if (!(await isAdmin(user))) return log('Denied: not admin.', 'error');
      const email = document.getElementById('target-email').value.trim().toLowerCase();
      if (!email) return log('Email required', 'error');
      const parent = document.getElementById('role-parent').checked;
      const student = document.getElementById('role-student').checked;
      const adminFlag = document.getElementById('role-admin').checked;
      const guest = document.getElementById('role-guest').checked;
      const guestDays = parseInt(document.getElementById('guest-days').value || '0', 10);
      const docRef = db.collection('allowedUsers').doc(email);
      const data = { updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
      if (parent) data.parent = true; else data.parent = false;
      if (student) data.student = true; else data.student = false;
      if (adminFlag) data.admin = true; else data.admin = false;
      if (guest) data.guest = true; else data.guest = false;
      if (guest && guestDays > 0) {
        // Store a human hint since we removed enforced expiration in rules
        const expireDate = new Date(Date.now() + guestDays * 86400000);
        data.guestNote = 'Intended expire (manual): ' + expireDate.toISOString();
      } else {
        data.guestNote = firebase.firestore.FieldValue.delete();
      }
      try {
        await docRef.set(data, { merge: true });
        log('Updated allowedUsers doc for ' + email, 'success');
      } catch (e2) {
        log('Write failed: ' + e2.message, 'error');
      }
    });
  </script>
</body>
</html>
